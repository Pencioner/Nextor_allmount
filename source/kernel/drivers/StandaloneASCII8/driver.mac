	.z80
	title	MSX-DOS 2 Copyright (1986)  IS Systems Ltd.
	subttl	Dummy driver bank for standalone kernel

;-----------------------------------------------------------------------------

; This is a dummy driver that allows using the kernel as a standalone cartridge
; without any associated hardware.
;

;-----------------------------------------------------------------------------

	INCLUDE	../../macros.inc
	INCLUDE	../../const.inc

QUERY_OK: equ 0
QUERY_TRUNCATED_STRING: equ 1
QUERY_INVALID_DEVICE: equ 2
QUERY_INIT_ERROR: equ 3
QUERY_NOT_IMPLEMENTED: equ 0FFh

DRVQ_GET_VERSION: equ 1
DRVQ_GET_STRING: equ 2
DRVQ_GET_INIT_PARAMS: equ 3
DRVQ_INIT: equ 4
DRVQ_GET_NUM_BOOT_DRIVES: equ 5
DRVQ_GET_DRIVE_BOOT_CONFIG: equ 6
DRVQ_GET_MAX_DEVICE: equ 7

DEVQ_GET_STRING: equ 1
DEVQ_GET_PARAMS: equ 2
DEVQ_GET_STATUS: equ 3

.NCOMP	equ	0FFh
.WRERR	equ	0FEh
.DISK	equ	0FDh
.NRDY	equ	0FCh
.DATA	equ	0FAh
.RNF	equ	0F9h
.WPROT	equ	0F8h
.UFORM	equ	0F7h
.SEEK	equ	0F3h
.IFORM	equ	0F0h
.IDEVN	equ	0B5h
.IPARM	equ	08Bh


	; ---- Routines and data available on kernel page 0

;* Get in A the current slot for page 1. Corrupts F.
;  Must be called by using CALBNK to bank 0:
;  xor a
;  ld ix,GSLOT1
;  call CALBNK

GSLOT1	equ	402Dh

;* This routine reads a byte from another bank.
;  Must be called by using CALBNK to the desired bank,
;  passing the address to be read in HL:
;  ld a,bank
;  ld hl,address
;  ld ix,RDBANK
;  call CALBNK

RDBANK	equ	403Ch

;* This routine temporarily switches kernel bank 0, then jumps to CALBAS in MSX BIOS.
;  This is necessary so that kernel bank is correct in case of BASIC error.

CALBAS	equ	403Fh	;On kernel page 0, not in MSX BIOS

;* This calls a routine in another bank.
;  Must be used if the driver spawns across more than one bank.
;  Input: A = bank
;         IX = routine address
;         AF' = AF for the routine
;         BC, DE, HL, IY = input for the routine

CALBNK	equ	4042h

;* Get in IX the work area address for the slot passed in A.
;  If A=0, then it uses the slot currently switched in page 1.
;  Returns A=current slot for page 1, if A=0 was passed.
;  Corrupts F.
;  Must be called by using CALBNK to bank 0:
;  ld a,slot
;  ex af,af'
;  xor a
;  ld ix,GWORK
;  call CALBNK

GWORK	equ	4045h

	if 0
	org 4000h
	db 41h,42h
	dw STARTx
	ds 4010h-$,0
STARTx:
	ld a,DRVQ_GET_STRING
	ld b,1
	ld d,12
	ld hl,0A000h
	call DRIVER_QUERY
	ret
	endif

	org 4100h

DRIVER_START:

	;*********************
	;***  DRIVER CODE  ***
	;*********************

	;Driver signature

	db	"NEXTORv3_DRIVER",0

	;Jump table

	jp	TIMER_INT
	jp	OEMSTAT
	jp	BASDEV
	jp	EXTBIO
	jp	DIRECT_0
	jp	DIRECT_1
	jp	DIRECT_2
	jp	DIRECT_3
	jp	DIRECT_4
	jp	DRIVER_QUERY
	jp	DEVICE_QUERY
	jp	CUSTOM_DRIVER_QUERY
	jp  CUSTOM_DEVICE_QUERY
	jp	READ_WRITE


	;--- Timer interrupt routine

TIMER_INT:
	ret	;TIMER_INT	
	ret
	ret

	;--- Handler for BASIC expanded statement ("CALL") handler.
	;    Works the expected way, except that CALBAS in kernel page 0
	;    must be called instead of CALBAS in MSX BIOS.

OEMSTAT:
	scf
	ret
	ret


	;--- Handler for BASIC expanded devices.
	;    Works the expected way, but see CALBAS exception for STATEMENT.

BASDEV:
	scf
	ret
	ret


	;--- Extended BIOS hook.
	;    Works the expected way, except that it must return
	;    D'=1 if the old hook must be called, D'=0 otherwise.
	;    It is entered with D'=1.

EXTBIO:
	ret
	ret
	ret


	;* Direct calls entry points.
	;  There is a jump table at address 7850h in ROM banks 0 and 3,
	;  that will be redirected here.

DIRECT_0:
	ret
	ret
	ret

DIRECT_1:
	ret
	ret
	ret

DIRECT_2:
	ret
	ret
	ret

DIRECT_3:
	ret
	ret
	ret

DIRECT_4:
	ret
	ret
	ret


	;--- Driver query
	;    Input:  A = Query index
	;            F, BC, DE, HL = Depends on the query
	;    Output: A = Error code:
	;                QUERY_OK: success
	;                QUERY_NOT_IMPLEMENTED: query not implemented
	;                Others: depends on the query
	;            F, BC, DE, HL = Depends on the query

DRIVER_QUERY:
	dec a
	jr z,DO_DRVQ_GET_VERSION
	dec a
	jr z,DO_DRVQ_GET_STRING
	dec a
	jr z,DO_DRVQ_GET_INIT_PARAMS
	dec a
	jr z,DO_DRVQ_INIT
	ld a,QUERY_NOT_IMPLEMENTED
	ret

DO_DRVQ_GET_VERSION:
	ld bc,0102h
	ld d,3
	xor a
	ret

DO_DRVQ_GET_STRING:
	ld a,b
	ld b,d
	ex de,hl
	dec a
	ld hl,STR_DRIVER_NAME
	jp z,OUTPUT_STRING
	dec a
	ld hl,STR_DRIVER_AUTHOR
	jp z,OUTPUT_STRING
	ld a,QUERY_NOT_IMPLEMENTED
	ret

DO_DRVQ_GET_INIT_PARAMS:
	if 0
	push de
	ld de,0C300h
	push de
	ld ix,1
	add ix,sp

	ld hl,GETINIT_MSG
	call PRINT_HL_USING_IX

	pop de
	pop de
	endif
	xor a
	ld b,1
	ld hl,0
	ret

DO_DRVQ_INIT:
	push de
	ld de,0C300h
	push de
	ld ix,1
	add ix,sp

	ld hl,INIT_MSG
	call PRINT_HL_USING_IX

	pop de
	pop de
	xor a
	ret

PRINT_HL_USING_IX:
	ld a,(hl)
	or a
	ret z
	call JPIX
	inc hl
	jr 	PRINT_HL_USING_IX

JPIX: jp (ix)

	.stresc on

STR_DRIVER_NAME: db "Dummy standalone driver",0 ; es bueno para la oreja, te lo pones asin y te crece la oreja",0
STR_DRIVER_AUTHOR: db "Konamiman",0

GETINIT_MSG: db "\r\nDummy driver, no pre-init needed\r\n",0
INIT_MSG: db "Dummy driver, no init needed\r\n",0


	;--- Device query
	;    Input:  A = Query index
	;            C = Device number
	;            F, B, DE, HL = Depends on the query
	;    Output: A = Error code:
	;                QUERY_OK: success
	;                QUERY_INVALID_DEVICE: Invalid device number
	;                QUERY_NOT_IMPLEMENTED: query not implemented
	;                Others: depends on the query
	;            F, BC, DE, HL = Depends on the query

DEVICE_QUERY:
if 0
	cp DEVQ_GET_PARAMS
	jr nz,DEVICE_QUERY_NOTIMP
	ld a,c
	cp 3
	ld a,QUERY_OK
	ret c
endif

DEVICE_QUERY_NOTIMP:
	ld a,QUERY_INVALID_DEVICE
	ret


	;--- Custom query
	;    Input:  A = Query index
	;            F, BC, DE, HL = Depends on the query
	;    Output: A = Error code:
	;                QUERY_OK: success
	;                QUERY_NOT_IMPLEMENTED: query not implemented
	;                Others: depends on the query
	;            F, BC, DE, HL = Depends on the query

CUSTOM_DEVICE_QUERY:
CUSTOM_DRIVER_QUERY:
	ld a,QUERY_NOT_IMPLEMENTED
	ret


    ;--- Read or write logical sectors from/to a device
    ;
    ;    Input:    Cy=0 to read, 1 to write
    ;              A = Device number, 1 to 255
    ;              B = Number of sectors to read or write
    ;              HL = Source or destination memory address for the transfer
    ;              DE = Address where the 4 byte sector number is stored.
    ;    Output:   A = Error code (the same codes of MSX-DOS are used):
    ;                  0: Ok
    ;                  .IDEVN: Invalid device or LUN
    ;                  .NRDY: Not ready
    ;                  .DISK: General unknown disk error
    ;                  .DATA: CRC error when reading
    ;                  .RNF: Sector not found
    ;                  .UFORM: Unformatted disk
    ;                  .WPROT: Write protected media, or read-only logical unit
    ;                  .WRERR: Write error
    ;                  .NCOMP: Incompatible disk.
    ;                  .SEEK: Seek error.

READ_WRITE:
	ld a,.IDEVN
	ret


	;Input:  HL = String
	;        DE = Destination
	;        B  = Max length including terminator
	;Output: A  = QUERY_OK or QUERY_TRUNCATED_STRING 
	
OUTPUT_STRING:
	ld a,b
	or a
	ret z

OUTPUT_STRING_LOOP:
	ld a,(hl)
	or a
	ld (de),a
	ret z

	inc hl
	inc de
	djnz OUTPUT_STRING

    dec de
	xor a
	ld (de),a
	ld a,QUERY_TRUNCATED_STRING
	ret

	ds 7ED0h-$,0FFh

	end

	;* Drive initialization, it is called twice:
	;  1) With A=0, B=number of available drives, and HL=available page 3 space.
        ;     It must return HL=required page 3 space, A=number of required drives,
        ;     and Cy=1 if timer interrupt routine is to be executed.
	;  2) With A=1 and B=number of allocated drives,
        ;     only if the required page 3 space was effectively allocated


.COMMENT \

----- DEFINED DRIVER QUERIES -----

1: Get driver version number

Input:  -
Output: A = QUERY_OK or QUERY_NOT_IMPLEMENTED
        Version in B.C.D (if A=QUERY_OK)

Same as the old DRV_VERSION, but version is now returned in B.C.D instead of A.B.C, and an error code is returned in A.

-----

2: Get driver information string

Input:  B  = String index:
             1: Driver name
             2: Driver author name
             3: Hardware name
             4: Hardware author name
             5: Serial number
        D  = Buffer size
        HL = Buffer address
Output: A = QUERY_OK: ok, full string provided
            QUERY_TRUNCATED_STRING: string was truncated due to buffer size too short
            QUERY_NOT_IMPLEMENTED: requested string not available

String is always provided zero-terminated, so the max effective string length is 254.

-----

3: Get driver initialization parameters

Input:  HL = Amount of work area available to allocate
        B  = Number of available drives in the system (???)
        C  = Flags:
             5: set if user is requesting reduced drive count (by pressing the 5 key)
             Others: 0
        DE = Address of a routine for printing a character	 
Output: B  = Flags
             0: TIMER_INT should be hooked
			 1-7: Must be zero
		HL  = Space required in page 3
Output: A = QUERY_OK, QUERY_INIT_ERROR or QUERY_NOT_IMPLEMENTED

If QUERY_NOT_IMPLEMENTED is returned, B=0 and HL=0 is assumed.
QUERY_INIT_ERROR will cause the "initialize driver" call to be skipped and the device to be ignored (not counted as an existing Nextor kernel)

Same as old DV_INIT when called with A=0, except that TIMER_INT flag is returned in B, not in Cy; an error code is returned in A; and DE is passed at input.

-----

4: Initialize driver

Input:  HL = Amount of work area allocated for the driver in page 3
        C  = Flags:
             5: set if user is requesting reduced drive count (by pressing the 5 key)
             Others: 0
        DE = Address of a routine for printing a character
Output: A = QUERY_OK, QUERY_INIT_ERROR or QUERY_NOT_IMPLEMENTED

QUERY_NOT_IMPLEMENTED is interpreted as equivalent to QUERY_OK
QUERY_INIT_ERROR will cause the device to be ignored (not counted as an existing Nextor kernel)

Same as old DV_INIT when called with A=0, except that number of allocated drives is not passed in B, DE is passed at input, and an error code can be returned.

-----

5: Get number of drives to allocate at boot time

Input:  C = Flags:
            0: 0 for DOS 2 mode, 1 for DOS 1 mode
            5: set if user is requesting reduced drive count (by pressing the 5 key)
            Others: 0
Output: A = QUERY_OK or QUERY_NOT_IMPLEMENTED
        B = Number of drives			

QUERY_NOT_IMPLEMENTED or returning B=255 means automatic number of drives (based on number of available devices)

Same as old DRV_CONFIG when invoked with A=1, except that DOS1/2 mode is now passed in bit 0 of C instead of in B; and A can return an error code.

-----

6: Get drive configuration at boot time

Input:  B = Relative drive number for driver
        C = Flags:
            0: 0 for DOS 2 mode, 1 for DOS 1 mode
            5: set if user is requesting reduced drive count (by pressing the 5 key)
            Others: 0
Output: A = QUERY_OK or QUERY_NOT_IMPLEMENTED
        B = Device number (0 to leave drive unmapped)

QUERY_NOT_IMPLEMENTED is equivalent to returning QUERY_OK and B=0.

Same as old DRV_CONFIG when invoked with A=2, except that:

- Drive number is now passed in B, not C.
- DOS1/2 is now passed in C, not B.
- Reduced drive count request is now passed in C.
- No LUN code returned anymore.
- An error code is returned in A.

-----

7: Get maximum supported device number

Input:  -
Output: A = QUERY_OK or QUERY_NOT_IMPLEMENTED
        B = Maximum supported device number

QUERY_NOT_IMPLEMENTED is equivalent to returning QUERY_OK and B=4


----- DEFINED DEVICE QUERIES -----

1: Get device information string

Input:  B  = String index:
             1: Manufacturer name
             2: Device name
             3: Serial number
        D  = Buffer size
        HL = Buffer address
Output: A = QUERY_OK: ok, full string provided
            QUERY_TRUNCATED_STRING: string was truncated due to buffer size too short
            QUERY_INVALID_DEVICE: device does not exist
            QUERY_NOT_IMPLEMENTED: requested string not available

String is always provided zero-terminated, so the max effective string length is 254.

Same as the old DEV_INFO (minus B=0 at input), but device id is passed in C instead of A, there's the buffer size parameter, and error codes differ.

-----

2: Get device parameters

Input:  HL = Buffer address, 0 for not returning info (only return error code)
Output: A = QUERY_OK: ok, device information provided
            QUERY_INVALID_DEVICE: device does not exist
            QUERY_NOT_IMPLEMENTED: query not implemented

On success, buffer filled with the following information:

+0 (1): Device type:
        0: Block device
        1: CD or DVD reader or recorder
        2-254: Unused. Additional codes may be defined in the future.
        255: Other
+1 (2): Sector size, 0 if this information does not apply or is
        not available.
+3 (4): Total number of available sectors.
        0 if this information does not apply or is not available.
+7 (1): Flags:
        bit 0: 1 if the device is removable.
        bit 1: 1 if the device is read only. A device that can dinamically
               be write protected or write enabled is not considered
               to be read-only.
        bit 2: 1 if the device is a floppy disk drive.
        bit 3: 1 if this device shouldn't be used for automapping.
        bits 4-7: must be zero.
+8 (2): Number of cylinders
+10 (1): Number of heads
+11 (1): Number of sectors per track

QUERY_NOT_IMPLEMENTED is interpreted as a block device with 512 byte sectors, unknown total number of sectors, and flags equal to 0.

This is the same as the old LUN_INFO, but device id is passed in C instead of A, there's no LUN index, and error codes differ.
Also HL=0 at input must be supported.

-----

3: Get device status

Input: -
Output: A = QUERY_OK: ok, device information provided
            QUERY_INVALID_DEVICE: device does not exist
            QUERY_NOT_IMPLEMENTED: query not implemented or device isn't removable
         B = Status for the specified device:
             0: The device exists but is not available at the moment
			    (typically this means: removable device with no medium inserted)
             1: The device is available and has not
                changed since the last status request.
             2: The device is available and has changed
                since the last status request
             3: The device is available, but it is not
                possible to determine whether it has been changed
                or not since the last status request.

QUERY_NOT_IMPLEMENTED is interpreted as retruning B=1.

For fixed devices the routine can return either QUERY_NOT_IMPLEMENTED, or QUERY_OK and B=1.

This is the same as the old DEV_STATUS, but device id is passed in C instead of A, there's no LUN index, and error codes differ.
Also the behavior when input is a non existing device is different (previously it would return a status of 0, now it returns QUERY_INVALID_DEVICE).

\

	end
